//快速排序QuickSort

//快速排序是目前所有内部排序算法中平均性能最优的排序算法

/*快速排序算法的基本原理为通过一次排序将要排序的数据分割成独立的两部分，
将序列分为两部分的中间数作为基准(par)，基准左边的数都要比基准右边的数要小，
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。*/

/*实现方法：快速排序主要通过划分来实现排序。根据说明，先设置待排序序列的第一个元素值为基准值。
            划分时首先从后往前扫描，即在序列后端找出比基准值小或相等的元素后将其移动到前端，
在从前往后扫描，即在序列后端找出比基准值大的元素将其移动到后端，直到找出基准值在序列中的最终排序位置*/

/*即：在待排序地整数序列中取第一个数作为基准值，然后根据基准值进行划分
从而将待排序列划分为不大于基准值者（称为左子序列）和大于基准值者（称为右子序列），
然后再对左子序列和右子序列分别进行快速排序，最终得到非递减地有序序列。*/
#include<stdio.h>//头文件
void quicksort(int a[], int n)//程序中实现快速排序地函数为quicksort
{            //第一个参数为数组，其本质是指针，调用时应给出数组名或数组中某个元素的地址
	int i, j;//定义变量名
	int pivot = a[0];	//设置基准值 
	i = 0;//赋值变量
	j = n - 1;//赋值变量
	while (i < j) //while循坏条件  当i小于j
	{
		//大于基准值者保持在原位置 
		while (i < j && a[j] > pivot) //当i小于j且a[j]大于pivot（基准）
		{
			j--; //j自减
		}
		if (i < j) //如果i小于j的话
		{
			a[i] = a[j];//将a[j]的值赋给a[i];
			i++;//i自加
		}
		//不大于基准值者保持在原位置 
		while (i < j && a[i] <= pivot)//条件：当i小于j且a[i]小于等于pivot（基准）时
		{
			i++; //i自加
		}
		if (i < j) //如果i小于j的话
		{
			a[j] = a[i];//将a[i]的值赋给a[j];
			j--;//j自减
		}
	}
	a[i] = pivot;	//基准元素归位 
	if (i > 1)
	{
		//递归地对左子序列 进行快速排序
		quicksort(a, i);
	}
	if (n - i - 1 > 1)/*在完成1次划分后，基准元素被放入 a[i] 
	                  那么分出来的左子序列由a[0]~a[i-1]这 i 个元素构成，
		              右子序列由a[i+1]~a[n-1]构成，接下来应递归地对左，右子序列进行快速排序*/
	{
		quicksort(a + i + 1, n - i - 1);
	}
}
int main() //主函数
{
	int i, arr[] = { 23,56,9,75,18,42,11,67 };//定义数组
	quicksort(arr, 8);//运用快速排序
	for (i = 0;i < 8;i++)//for循环
	{
		printf("%d ", arr[i]);//将数组arr[i]打印出来
	}return 0;
}
